;   Copyright (C) 2019 e474 <e474sr@gmail.com>
;
;   This program is free software; you can redistribute it and/or modify
;   it under the terms of the GNU General Public License as published by
;   the Free Software Foundation; either version 3 of the License, or
;   (at your option) any later version.
;
;   This program is distributed in the hope that it will be useful,
;   but WITHOUT ANY WARRANTY; without even the implied warranty of
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;   GNU General Public License for more details.
;
;   You should have received a copy of the GNU General Public License
;   along with this program; if not, write to the Free Software
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

;
;
;  ATR Maker Deluxe
;

;
; Handy system equates defined as part of ATASM
;

	.INCLUDE "OS.asm"
	.INCLUDE "ANTIC.asm"
	.INCLUDE "CHIPS.asm"

	.INCLUDE "constequ.asm"
;
; page zero indirection pointers
;
ZSOURCE		= 	$82
ZSOURCE_LO 	= 	$82
ZSOURCE_HI 	= 	$83

ZDEST		=	$84
ZDEST_LO	=	$84
ZDEST_HI	=	$85

ZFIELD_STRUCTURE = $86
ZFIELD_STRUCTURE_LO = $86
ZFIELD_STRUCTURE_HI = $87

;
; page zero jump vectors
;

ZCOMMAND_VECTOR	= $88
ZCOMMAND_VECTOR_LO	= $88
ZCOMMAND_VECTOR_HI	= $89

;
; page zero 16 bit multiplication registers
;

ZMSOURCE1		=	$8A
ZMSOURCE1_LO	=	$8A
ZMSOURCE1_HI	=	$8B

ZMSOURCE2		=	$8C
ZMSOURCE2_LO	=	$8C
ZMSOURCE2_HI	=	$8D

ZMSCRATCH		=	$8E
ZMSCRATCH_LO	=	$8E
ZMSCRATCH_HI	=	$8F


EOZ = $9C 



	* = $2000

	JMP PROGRAM_INIT

DISPLAY_LIST
	.BYTE $70,$70,$70	; 3 blank lines
	.BYTE $42			; Graphics 0 text mode line 1
	.WORD SCREEN_TEXT_START
	.BYTE $02,$02,$02
	.BYTE $02,$02,$02,$02
	.BYTE $02,$02,$02,$02	
	.BYTE $02,$02,$02,$02	
	.BYTE $02,$02,$02,$02	
	.BYTE $02,$02,$02,$02	
	.BYTE $41
	.WORD DISPLAY_LIST
	

SCREEN_TEXT_START 

	* = * + [25 * TEXT_LINE_WIDTH] ; + amount of memory for graphical sector copy screen memory (tbd)
	

	.INCLUDE "TEXT.asm"	
	


PROGRAM_INIT

	JSR CLEAR_TEXT_SCREEN
	
;	OPEN 2,4,0,"K:"									; open keyboard for reading
	
	LDX #KEYBOARD_INPUT_HANDLE
	LDA #COPN
	STA ICCOM,X
	LDA #4
	STA ICAUX1,X
	LDA #0
	STA ICAUX2,X
	LDA # <KEYBOARD_DEVICE_TEXT
	STA ICBADR,X
	LDA # >KEYBOARD_DEVICE_TEXT
	STA ICBADR+1,X
	JSR CIO
	
	LDA #0
	STA SDMCTL
	LDA #<DISPLAY_LIST
	STA SDLSTL
	LDA #>DISPLAY_LIST
	STA SDLSTH
	LDA #$22
	STA SDMCTL
	
	LDA #COLOR_GREEN
	STA COLOR2

	JSR CLEAR_SECTOR_BUFFER
		
	JSR DISPLAY_MAIN_MENU_LAYOUT
	

PROCESS_OPTIONS

;	BGET 2,OPTION_CHAR,1

	LDX #KEYBOARD_INPUT_HANDLE
	LDA #CGBINR
	STA ICCOM,X
	LDA # <OPTION_CHAR
	STA ICBADR,X
	LDA # >OPTION_CHAR
	STA ICBADR+1,X
	LDA # <1
	STA ICBLEN,X
	LDA # >1
	STA ICBLEN+1,X
	JSR CIO

	JSR CLEAR_INTERACTIVE_QUESTION_AREA

	JSR CLEAR_DISK_HAS_BAD_SECTOR_AREA

; PROCESS INPUT CHARACTER

	LDA OPTION_CHAR
	JSR PROCESS_MAIN_MENU_INPUT
;	JSR CLEAR_TEXT_SCREEN
	
	JMP PROCESS_OPTIONS

DESTINATION_DRIVE_INPUT_HANDLER
	LDA #<DESTINATION_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>DESTINATION_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI
	
	JSR UPDATE_FIELD
	
	LDA DESTINATION_DISPLAY_DRIVE
	CLC
	ADC #$20
	STA EXISTING_FILE_DRIVE_NUMBER
	
	JSR DISPLAY_STATUS_LINE
	RTS
	
SOURCE_DRIVE_INPUT_HANDLER
	LDA #<SOURCE_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>SOURCE_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI
	
	JSR UPDATE_FIELD
	JSR DISPLAY_STATUS_LINE
	RTS
	
MODE_CHANGE_INPUT_HANDLER
	LDA #<MODE_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>MODE_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI
	
	JSR UPDATE_FIELD
	RTS


LOG_FILE_CHANGE_INPUT_HANDLER

; Setup destination pointer to field for mode value

	LDA #<LOG_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>LOG_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI
	
	JSR UPDATE_FIELD
	RTS

NOTE_PROMPT_INPUT_HANDLER

	LDA #<NOTE_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>NOTE_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	
	RTS
	
VIEW_SECTORS_INPUT_HANDLER

	LDA #<VIEW_SECTORS_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>VIEW_SECTORS_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	
	RTS

ERROR_SECTOR_INPUT_HANDLER

	LDA #<ERROR_SECTORS_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>ERROR_SECTORS_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	
	RTS

HELP_TEXT_INPUT_HANDLER

	JSR CLEAR_TEXT_SCREEN
	
	LDA #<HELP_TEXT
	STA ZSOURCE_LO
	LDA #>HELP_TEXT
	STA ZSOURCE_HI
	
	LDA #<[SCREEN_TEXT_START]
	STA ZDEST_LO
	LDA #>[SCREEN_TEXT_START]
	STA ZDEST_HI

	JSR DISPLAY_TEXT_UP_TO_EOZ
	
DONE_DISPLAYING_HELP	

;	BGET 2,HELP_TEXT_CHAR,1

	LDX #KEYBOARD_INPUT_HANDLE
	LDA #CGBINR
	STA ICCOM,X
	LDA # <HELP_TEXT_CHAR
	STA ICBADR,X
	LDA # >HELP_TEXT_CHAR
	STA ICBADR+1,X
	LDA # <1
	STA ICBLEN,X
	LDA # >1
	STA ICBLEN+1,X
	JSR CIO

	LDA HELP_TEXT_CHAR
	CMP #'C
	BNE DONE_DISPLAYING_HELP
	JSR CLEAR_TEXT_SCREEN
	JSR DISPLAY_MAIN_MENU_LAYOUT
	RTS

	
SPACE_BAR_INPUT_HANDLER

; check that source and destination are not the same

	LDY #CURRENT_FIELD_VALUE
	LDA SOURCE_FIELD_DATA,Y		; how to handle bad sectors
	CMP DESTINATION_FIELD_DATA,Y
	
	BNE SOURCE_AND_DESTINATION_ARE_DIFFERENT

	
	LDA #<SOURCE_IS_DESTINATION_ERROR_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>SOURCE_IS_DESTINATION_ERROR_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	
	RTS
	



SOURCE_AND_DESTINATION_ARE_DIFFERENT
	LDA #COLOR_LITE_BLUE
	STA COLOR2

;
; this sub-routine handles the disk conversion to ATR
; based on the values in the fields
;

; setup output pointers to start of screen memory, bound to be useful
; later (leave space for status line)

	LDA #<[ SCREEN_TEXT_START + [ 2 * TEXT_LINE_WIDTH]]
	STA ZDEST_LO
	LDA #>[SCREEN_TEXT_START + [ 2 * TEXT_LINE_WIDTH]]
	STA ZDEST_HI

	JSR CHECK_DRIVE_STATUS
	BCC DRIVE_PRESENT
;
; drive not present
; tell the user, wait for input, then return to main menu code
;
BAD_DISK_START
	LDA #<CHECK_DRIVE_STATUS_TEXT_CANT_DETECT_DRIVE
	STA ZSOURCE_LO
	LDA #>CHECK_DRIVE_STATUS_TEXT_CANT_DETECT_DRIVE
	STA ZSOURCE_HI

	JSR DISPLAY_TEXT_UP_TO_EOZ
	JSR WAIT_TO_CONTINUE
	JSR CLEAR_TEXT_SCREEN 
	JSR DISPLAY_MAIN_MENU_LAYOUT

	LDA #COLOR_GREEN
	STA COLOR2


	RTS								; back to processing main menu input
	
DRIVE_PRESENT	

	JSR SYNTHESISE_PERCOM_BLOCK		; this will setup single/enhanced density
									; disk Percom block, which will allow
									; first 3 sectors to be read OK, then 
									; do another get status and a proper
									; get percom block once disk is up
									; and returning data


	; read first 3 single density sectors
	JSR READ_FIRST_THREE_SINGLE_DENSITY_SECTORS
	BCS BAD_DISK_START				; shouldn't happen

	JSR CHECK_DRIVE_STATUS
	JSR READ_PERCOM_BLOCK
	BCC PERCOM_BLOCK_EXISTS

	JSR SYNTHESISE_PERCOM_BLOCK		; drive doesn't support Percom Block, so
									; set one up from info returned by get_status

PERCOM_BLOCK_EXISTS

	JSR SOME_DRIVES_ARE_CONFUSED


	JSR UPDATE_STATUS_SECTOR_SIZE
	JSR UPDATE_STATUS_NUMBER_OF_HEADS

	JSR CREATE_ATR_HEADER_FROM_PERCOM_BLOCK
	
READ_SECTORS_3_OK

; file IO actions

; check if file already exists

	JSR CHECK_FOR_EXISTING_FILE
	BCC FILE_DOES_NOT_EXIST
	
	LDA #COLOR_GREEN
	STA COLOR2

	RTS  	
	
	
FILE_DOES_NOT_EXIST

; open fresh file for output

	; OPEN 5,8,0,EXISTING_FILE_NAME

	LDX #ATR_FILE_HANDLE
	LDA #COPN
	STA ICCOM,X
	LDA #8
	STA ICAUX1,X
	LDA #0
	STA ICAUX2,X
	LDA # <EXISTING_FILE_NAME
	STA ICBADR,X
	LDA # >EXISTING_FILE_NAME
	STA ICBADR+1,X
	JSR CIO

	BPL OPEN_EXISTING_FILE_OK

	JSR CIO_ERROR

	LDA #COLOR_GREEN
	STA COLOR2

	RTS

OPEN_EXISTING_FILE_OK

; write ATR header

	; BPUT 5,ATR_HEADER,ATR_HEADER_LENGTH

	LDX #ATR_FILE_HANDLE
	LDA #CPBINR
	STA ICCOM,X
	LDA # <ATR_HEADER
	STA ICBADR,X
	LDA # >ATR_HEADER
	STA ICBADR+1,X
	LDA # <ATR_HEADER_LENGTH
	STA ICBLEN,X
	LDA # >ATR_HEADER_LENGTH
	STA ICBLEN+1,X
	JSR CIO

; write first 3 sectors


;	BPUT 5, SECTOR_BUFFER, FIRST_THREE_SECTOR_SIZE

	LDX #ATR_FILE_HANDLE
	LDA #CPBINR
	STA ICCOM,X
	LDA # <SECTOR_BUFFER
	STA ICBADR,X
	LDA # >SECTOR_BUFFER
	STA ICBADR+1,X
	LDA # <FIRST_THREE_SECTOR_SIZE
	STA ICBLEN,X
	LDA # >FIRST_THREE_SECTOR_SIZE
	STA ICBLEN+1,X
	JSR CIO

; read from sector 4 onwards

	LDA #4
	STA DAUX1
	STA NEXT_SECTOR_TO_READ
	LDA #0
	STA DAUX2
	STA NEXT_SECTOR_TO_READ+1

LOOP_COPY_SECTOR_TO_FILE
	LDA #<SECTOR_BUFFER				; reset input buffer as it gets trashed by CIO call to 
	STA DBUFLO						; write file
	LDA #>SECTOR_BUFFER
	STA DBUFHI

;   read next sector

	JSR READ_SECTOR

; write sector to file

	JSR WRITE_SECTOR_TO_ATR_FILE
	BCS DONE_WRITING_FILE
	
	
	
	CLC
	LDA #1
	ADC NEXT_SECTOR_TO_READ
	STA NEXT_SECTOR_TO_READ
	STA DAUX1
	LDA #0
	ADC NEXT_SECTOR_TO_READ+1
	STA NEXT_SECTOR_TO_READ+1
	STA DAUX2

; check if last sector read

	DEC REMAINING_NUMBER_OF_SECTORS
	BNE LOOP_COPY_SECTOR_TO_FILE
	DEC REMAINING_NUMBER_OF_SECTORS+1
	LDA REMAINING_NUMBER_OF_SECTORS+1
	CMP #$FF
	BNE LOOP_COPY_SECTOR_TO_FILE

; jmp to loop if not last sector

;	CLOSE 5

; close file, tell user job done

DONE_WRITING_FILE

	JSR CLOSE_ATR_FILE

	JSR INFORM_CONVERSION_COMPLETE

	LDA #COLOR_GREEN
	STA COLOR2

	RTS

FILE_OR_FORMAT_CHANGE_INPUT_HANDLER

	JSR GET_FILE_NAME_TEXT
	
	JSR REFRESH_MAIN_MENU
	
	RTS

; not implemented yet

INTERFACE_LANGUAGE_INPUT_HANDLER
BACKGROUND_COLOR_INPUT_HANDLER
TEXT_COLOR_INPUT_HANDLER
UPDATE_SETTINGS_INPUT_HANDLER

	RTS

;
; Subroutines
;
;
;
;
;
;
;
;
;
;
; WRITE_SECTOR_TO_ATR_FILE 	- writes the currently buffered sector (in SECTOR_BUFFER) to the open file specified by ATR_FILE_HANDLE,
;							- size of buffered sector is specified in the Percom Block, PERCOM_BYTES_PER_SECTOR_LO and
;							- PERCOM_BYTES_PER_SECTOR_HI
;

WRITE_SECTOR_TO_ATR_FILE

	LDX #ATR_FILE_HANDLE
	LDA #CPBINR
	STA ICCOM,X
	LDA # <SECTOR_BUFFER
	STA ICBADR,X
	LDA # >SECTOR_BUFFER
	STA ICBADR+1,X
	LDA PERCOM_BYTES_PER_SECTOR_LO
	STA ICBLEN,X
	LDA PERCOM_BYTES_PER_SECTOR_HI
	STA ICBLEN+1,X
	JSR CIO
	BPL WROTE_SECTOR_TO_FILE
	
	JSR CIO_ERROR
	SEC
	RTS
	
WROTE_SECTOR_TO_FILE	
	CLC
	RTS

CIO_ERROR
;
; Y contains CIO Error

; convert to error code

	STY BIN_VAL
	LDA #0
	STA BIN_VAL+1

	JSR BINBCD16

	LDA BCD_VAL
	CLC
	AND #$0F
	TAY
	LDA DECIMAL_TO_SCREEN,Y
	STA FILE_ERROR_TEXT+2
	
	LDA BCD_VAL
	AND #$F0
	CLC
	ROR 
	ROR 
	ROR 
	ROR 
	
	TAY
	LDA DECIMAL_TO_SCREEN,Y	
	STA FILE_ERROR_TEXT+1

	LDA BCD_VAL+1
	CLC
	AND #$0F
	TAY
	LDA DECIMAL_TO_SCREEN,Y
	STA FILE_ERROR_TEXT

	LDA #<FILE_ERROR_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>FILE_ERROR_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	

	LDA #COLOR_RED_ORANGE
	STA COLOR2
	
	JSR WAIT_TO_CONTINUE

	JSR CLEAR_INTERACTIVE_QUESTION_AREA

	LDA #COLOR_GREEN
	STA COLOR2

	RTS

SOME_DRIVES_ARE_CONFUSED
	LDA PERCOM_SECTORS_PER_TRACK_LO
	CMP #18
	BNE PROBABLY_TELLING_THE_TRUTH
	LDA PERCOM_BYTES_PER_SECTOR_HI
	BNE PROBABLY_TELLING_THE_TRUTH
	LDA PERCOM_BYTES_PER_SECTOR_LO
	CMP #$80
	BNE PROBABLY_TELLING_THE_TRUTH

; try reading sectors after sector 720
	
	LDA #<[ SECTOR_BUFFER + [3 * SINGLE_DENSITY_SECTOR_SIZE]]
	STA DBUFLO
	LDA #>[ SECTOR_BUFFER + [3 * SINGLE_DENSITY_SECTOR_SIZE]]
	STA DBUFHI
	
	LDA #$80

	LDY #<762		; 762 decimal, $2FA
	STY DAUX1
	LDY #>762
	STY DAUX2

;	STY PERCOM_BYTES_PER_SECTOR_HI
	
QUICK_TEST_LOOP	
	JSR READ_SECTOR_QUICK_TEST
	
	BCS ERROR_READING_ENHANCED_DENSITY_END_SECTORS
	
	LDA #26		; it *is* enhanced density
	STA PERCOM_SECTORS_PER_TRACK_LO
	CLC
	RTS	
	
ERROR_READING_ENHANCED_DENSITY_END_SECTORS	
	INC DAUX1
	BNE QUICK_TEST_LOOP
	SEC
	RTS
	

PROBABLY_TELLING_THE_TRUTH
	CLC
	RTS




;
; CREATE_ATR_HEADER_FROM_PERCOM_BLOCK	- 
;

CREATE_ATR_HEADER_FROM_PERCOM_BLOCK

; update ATR header with static values
		
	LDA PERCOM_BYTES_PER_SECTOR_LO
	STA ATR_W_SEC_SIZE
	STA PARA_SECTOR_SIZE_LO
	
	LDA PERCOM_BYTES_PER_SECTOR_HI
	STA ATR_W_SEC_SIZE + 1
	STA PARA_SECTOR_SIZE_HI

; calculate ATR header size field

; convert sector size into sector size in paragraphs (divide sector
; size by $10)

	LSR PARA_SECTOR_SIZE_HI
	ROR PARA_SECTOR_SIZE_LO   	; divide by 2
	LSR PARA_SECTOR_SIZE_HI
	ROR PARA_SECTOR_SIZE_LO		; divide by 4
	LSR PARA_SECTOR_SIZE_HI
	ROR PARA_SECTOR_SIZE_LO		; divide by 8
	LSR PARA_SECTOR_SIZE_HI
	ROR PARA_SECTOR_SIZE_LO		; divide by 16

; calculate number of sectors on disk
; multiply number of sectors per track (word) by number of tracks (byte)

	LDA PERCOM_NUMBER_OF_TRACKS
	STA ZMSOURCE1_LO
	LDA #0
	STA ZMSOURCE1_HI

	LDA PERCOM_SECTORS_PER_TRACK_LO
	STA ZMSOURCE2_LO
	LDA PERCOM_SECTORS_PER_TRACK_HI
	STA ZMSOURCE2_HI
		
	JSR MULTIPLY_16BIT

	LDA ZMSOURCE1_LO
	STA CALCULATED_TOTAL_NUMBER_OF_SECTORS
	LDA ZMSOURCE1_HI
	STA CALCULATED_TOTAL_NUMBER_OF_SECTORS+1
	LDA ZMSOURCE2_LO
	STA CALCULATED_TOTAL_NUMBER_OF_SECTORS+2
	LDA ZMSOURCE2_HI
	STA CALCULATED_TOTAL_NUMBER_OF_SECTORS+3
	
; check that number of sectors is less than 64K

; check not implemented yet!
	
; have read 3 sectors already, so can calculate the remaining number of sectors

	SEC
	LDA CALCULATED_TOTAL_NUMBER_OF_SECTORS+2
	SBC #3
	STA REMAINING_NUMBER_OF_SECTORS
	LDA CALCULATED_TOTAL_NUMBER_OF_SECTORS+3
	SBC #0
	STA REMAINING_NUMBER_OF_SECTORS+1


; at this point just need to calculate total size of disk in Paragraphs ($10 bytes)

	
	LDA CALCULATED_TOTAL_NUMBER_OF_SECTORS+2
	STA ZMSOURCE1_LO
	LDA CALCULATED_TOTAL_NUMBER_OF_SECTORS+3
	STA ZMSOURCE1_HI

	LDA PARA_SECTOR_SIZE_LO
	STA ZMSOURCE2_LO
	LDA PARA_SECTOR_SIZE_HI
	STA ZMSOURCE2_HI
		
	JSR MULTIPLY_16BIT

	LDA ZMSOURCE2_LO
	STA ATR_W_PARS
	LDA ZMSOURCE2_HI
	STA ATR_W_PARS+1

; need to take off extra space from 3 * 128 byte sectors, if Percom Block sectors are bigger,
; well one day

	RTS

;
; CHECK_FOR_EXISTING_FILE - 
;



CHECK_FOR_EXISTING_FILE
	; try and open the file specified in EXISTING_FILE_NAME
	
;	OPEN 5,4,0,EXISTING_FILE_NAME

	LDX #ATR_FILE_HANDLE
	LDA #COPN
	STA ICCOM,X
	LDA #4
	STA ICAUX1,X
	LDA #0
	STA ICAUX2,X
	LDA # <EXISTING_FILE_NAME
	STA ICBADR,X
	LDA # >EXISTING_FILE_NAME
	STA ICBADR+1,X
	JSR CIO
	
	BPL FILE_EXISTS
	JMP DOES_NOT_EXIST

FILE_EXISTS	

	JSR CLOSE_ATR_FILE
;	CLOSE 5
	
	JSR OK_TO_OVERWRITE_EXISTING_FILE

	LDA #COLOR_LITE_BLUE
	STA COLOR2
	
	RTS
	
DOES_NOT_EXIST
	JSR CLOSE_ATR_FILE
	
	;CLOSE 5
OK_TO_WRITE_FILE	
	JSR CLEAR_INTERACTIVE_QUESTION_AREA
	CLC				; no problem to proceed
	RTS

OK_TO_OVERWRITE_EXISTING_FILE

	LDA #COLOR_RED_ORANGE
	STA COLOR2

	LDA #<OVERWRITE_FILE_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>OVERWRITE_FILE_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	

	JSR ASK_YES_OR_NO
	
	BCC ANSWERED_YES_TO_OVERWRITE
	LDA #COLOR_GREEN
	STA COLOR2
	
	JSR CLEAR_INTERACTIVE_QUESTION_AREA
	SEC
	RTS
	
ANSWERED_YES_TO_OVERWRITE	
	JSR CLEAR_INTERACTIVE_QUESTION_AREA
	JSR INFORM_OVERWRITING_FILE

	LDA #COLOR_LITE_BLUE
	STA COLOR2

	CLC
	RTS

INFORM_OVERWRITING_FILE

	LDA #<OVERWRITING_FILE_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>OVERWRITING_FILE_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	

	RTS

INFORM_CONVERSION_COMPLETE

	LDA #<CONVERSION_COMPLETE_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>CONVERSION_COMPLETE_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	

	RTS

MULTIPLY_16BIT

; this code was adapted from http://forum.6502.org/viewtopic.php?t=447

    LDA  ZMSOURCE2_LO    ; Get the multiplicand and
    STA  ZMSCRATCH_LO    ; put it in the scratchpad.
    LDA  ZMSOURCE2_HI
    STA  ZMSCRATCH_HI
    LDA  #0
    STA  ZMSOURCE2_LO    ; Zero-out the original multiplicand area.
    STA  ZMSOURCE2_HI

    LDY  #$10  ; We'll loop 16 times.
LL1 ASL  ZMSOURCE2_LO    ; Shift the entire 32 bits over one bit position.
    ROL  ZMSOURCE2_HI
    ROL  ZMSOURCE1_LO
    ROL  ZMSOURCE1_HI
    BCC  LL2    ; Skip the adding-in to the result if
               ; the high bit shifted out was 0.
    CLC        ; Else, add multiplier to intermediate result.
    LDA  ZMSCRATCH_LO
    ADC  ZMSOURCE2_LO
    STA  ZMSOURCE2_LO
    LDA  ZMSCRATCH_HI
    ADC  ZMSOURCE2_HI
    STA  ZMSOURCE2_HI

    LDA  #0    ; If C=1, incr lo byte of hi cell.
    ADC  ZMSOURCE1_LO
    STA  ZMSOURCE1_LO

LL2 DEY        ; If we haven't done 16 iterations yet,
    BNE  LL1    ; then go around again.

    RTS


SYNTHESISE_PERCOM_BLOCK
;
; single or enhanced density
; 
; Byte 0 of status block:
; bit 5 - Double density
; bit 7 set = Enhanced/Medium density
;
; setup common single/enhanced density Percom Block fields

	LDA #40
	STA PERCOM_NUMBER_OF_TRACKS
	LDA #0
	STA PERCOM_SECTORS_PER_TRACK_HI
	STA PERCOM_STEP_RATE
	STA PERCOM_NUMBER_OF_SIDES
	STA PERCOM_RECORD_METHOD
	STA PERCOM_DRIVE_ONLINE
	STA PERCOM_UNUSED_1
	STA PERCOM_UNUSED_2
	STA PERCOM_UNUSED_3
	STA PERCOM_BYTES_PER_SECTOR_HI
	LDA #$80
	STA PERCOM_BYTES_PER_SECTOR_LO		

	LDA DRIVE_STATUS_BUFFER
	AND #$80			; check bit 7 set?
	BEQ SINGLE_DENSITY_720_SECTOR_DISK

ENHANCED_DENSITY_1040_SECTOR_DISK	
	LDA #26
	STA PERCOM_SECTORS_PER_TRACK_LO
	RTS	

SINGLE_DENSITY_720_SECTOR_DISK
	LDA #18
	STA PERCOM_SECTORS_PER_TRACK_LO
	RTS

;
; read sectors 1-3, this should set up Percom Block for current disk on
; all drives that support it

READ_FIRST_THREE_SINGLE_DENSITY_SECTORS

	LDA #$80
	STA PERCOM_BYTES_PER_SECTOR_LO

	LDY #1
	STY DAUX1
	DEY
	STY DAUX2
	STY PERCOM_BYTES_PER_SECTOR_HI

	LDA #<SECTOR_BUFFER
	STA DBUFLO
	LDA #>SECTOR_BUFFER
	STA DBUFHI
	
	JSR READ_SECTOR
	BMI ERROR_READING_FIRST_SECTORS

	INC DAUX1 					; next sector (2)

	LDA #< [ SECTOR_BUFFER + SINGLE_DENSITY_SECTOR_SIZE]
	STA DBUFLO
	LDA #> [SECTOR_BUFFER  + SINGLE_DENSITY_SECTOR_SIZE]
	STA DBUFHI
		
	JSR READ_SECTOR
	BMI ERROR_READING_FIRST_SECTORS

	INC DAUX1 					; next sector (3)

	LDA #< [ SECTOR_BUFFER + [ SINGLE_DENSITY_SECTOR_SIZE * 2]]
	STA DBUFLO
	LDA #> [SECTOR_BUFFER  + [ SINGLE_DENSITY_SECTOR_SIZE * 2]]
	STA DBUFHI
		
	JSR READ_SECTOR
	BMI ERROR_READING_FIRST_SECTORS

	CLC
	RTS

ERROR_READING_FIRST_SECTORS
	LDA #<CHECK_SECTOR_1_TEXT_COULD_NOT_READ_SECTOR
	STA ZSOURCE_LO
	LDA #>CHECK_SECTOR_1_TEXT_COULD_NOT_READ_SECTOR
	STA ZSOURCE_HI

	JSR DISPLAY_TEXT_UP_TO_EOZ

	JSR WAIT_TO_CONTINUE

	JSR REFRESH_MAIN_MENU

	SEC	
	RTS

CLEAR_SECTOR_BUFFER
	LDY PERCOM_SECTORS_PER_TRACK_LO
	LDA #0
LOOP_CLEAR_SECTOR_BUFFER
	STA SECTOR_BUFFER,Y
	DEY
	BNE LOOP_CLEAR_SECTOR_BUFFER
	RTS

DUMP_SECTOR_TO_DISPLAY
	LDY #0
LOOP_COPY_SECTOR_TO_SCREEN
	LDA SECTOR_BUFFER,Y
	STA SCREEN_TEXT_START + [ 5 * TEXT_LINE_WIDTH ] , Y
	INY
	CPY #$80
	BNE LOOP_COPY_SECTOR_TO_SCREEN
	RTS	

READ_SECTOR

	LDA #<RETRY_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>RETRY_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI
	
	LDY #CURRENT_FIELD_VALUE
	LDA ERROR_SECTORS_FIELD_DATA,Y		; how to handle bad sectors
	
; values
;	.SBYTE +$80,"Retry 5 then ask"
;	.SBYTE +$80,"Retry 5 then skip"
;	.SBYTE +$80,"Skip"
;	.SBYTE +$80,"Ask"
	
	BNE PROCESS_NON_DEFAULT_ERRORS
	LDA #5
	STA RETRY_COUNT
	STA RETRY_COUNT_MAX
	LDA #1
	STA ASK_ON_BAD_SECTOR	
	JMP SETUP_BAD_SECTOR_RETRY_FIELD
PROCESS_NON_DEFAULT_ERRORS
	CMP #1
	BNE NO_BAD_SECTOR_RETRIES
	LDA #5
	STA RETRY_COUNT
	STA RETRY_COUNT_MAX
	LDA #0
	STA ASK_ON_BAD_SECTOR	
	JMP SETUP_BAD_SECTOR_RETRY_FIELD
NO_BAD_SECTOR_RETRIES
	LDX #1
	STX RETRY_COUNT
	STX RETRY_COUNT_MAX
	
	CMP #2
	BNE BAD_SECTOR_ASK_USER
	LDX #0
	STX ASK_ON_BAD_SECTOR
	JMP SETUP_BAD_SECTOR_RETRY_FIELD
BAD_SECTOR_ASK_USER
	LDX #1
	STX RETRY_COUNT
	STX RETRY_COUNT_MAX

	STA ASK_ON_BAD_SECTOR	

SETUP_BAD_SECTOR_RETRY_FIELD
	LDY #CURRENT_FIELD_VALUE
	LDA #0
	STA RETRY_FIELD_DATA,Y				; Supplied by user

	LDA RETRY_COUNT_MAX
	STA RETRY_COUNT
	
RETRY_READ_SECTOR


	LDA #'R										
	STA DCOMND
	LDA #$40
	STA DSTATS
	LDA #$31
	STA DDEVIC
	LDA CALCULATED_SOURCE_DRIVE_NUMBER
	STA DUNIT
	
	LDA PERCOM_BYTES_PER_SECTOR_LO
	STA DBYTLO
	LDA PERCOM_BYTES_PER_SECTOR_HI
	STA DBYTHI
	
	LDA #20						
	STA DTIMLO
	
	JSR UPDATE_STATUS_READ_SECTOR

    JSR	SIOV						
    
    BMI	SIO_READ_SECTOR_ERROR

	JSR CLEAR_INTERACTIVE_QUESTION_AREA

 	CLC
	RTS
	
SIO_READ_SECTOR_ERROR

	JSR CLEAR_SECTOR_BUFFER

	LDA #<RETRY_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>RETRY_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	

	DEC RETRY_COUNT

	BNE RETRY_READ_SECTOR	

	LDA ASK_ON_BAD_SECTOR
	BEQ NO_MORE_RETRIES

	LDA #<RETRY_ANOTHER_5_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>RETRY_ANOTHER_5_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	
	
	JSR ASK_YES_OR_NO

	
	BCS NO_MORE_RETRIES

	JSR CLEAR_INTERACTIVE_QUESTION_AREA

	LDA #5
	STA RETRY_COUNT	
	STA RETRY_COUNT_MAX	

	JMP SETUP_BAD_SECTOR_RETRY_FIELD

NO_MORE_RETRIES
	JSR CLEAR_INTERACTIVE_QUESTION_AREA

	LDA #<DISK_HAS_BAD_SECTORS_ERROR_FIELD_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>DISK_HAS_BAD_SECTORS_ERROR_FIELD_DATA
	STA ZFIELD_STRUCTURE_HI

	JSR UPDATE_FIELD	



	SEC
	RTS

READ_SECTOR_QUICK_TEST



	LDA #'R										
	STA DCOMND
	LDA #$40
	STA DSTATS
	LDA #$31
	STA DDEVIC
	LDA CALCULATED_SOURCE_DRIVE_NUMBER
	STA DUNIT
	
	LDA PERCOM_BYTES_PER_SECTOR_LO
	STA DBYTLO
	LDA PERCOM_BYTES_PER_SECTOR_HI
	STA DBYTHI
	
	LDA #20						
	STA DTIMLO

    JSR	SIOV						
    
    BMI	SIO_READ_SECTOR_ERROR_QUICK_TEST

 	CLC
	RTS
	
SIO_READ_SECTOR_ERROR_QUICK_TEST


	SEC
	RTS












CLEAR_DISK_HAS_BAD_SECTOR_AREA
	LDY #0
	TYA
CLEAR_DISK_HAS_BAD_SECTOR_AREA_JUST_IN_CASE
	STA [SCREEN_TEXT_START  + [BAD_SECTOR_RETRY_FIELD_LINE * TEXT_LINE_WIDTH]],Y
	INY
	CPY #TEXT_LINE_WIDTH	
	BNE CLEAR_DISK_HAS_BAD_SECTOR_AREA_JUST_IN_CASE
	RTS



CLEAR_INTERACTIVE_QUESTION_AREA
	LDY #0
	TYA
CLEAR_BAD_SECTOR_INFO_LINE_JUST_IN_CASE
	STA [SCREEN_TEXT_START  + [RETRY_FIELD_LINE * TEXT_LINE_WIDTH]],Y
	INY
	CPY #TEXT_LINE_WIDTH	
	BNE CLEAR_BAD_SECTOR_INFO_LINE_JUST_IN_CASE
	RTS

GET_FILE_NAME_TEXT
	JSR CLEAR_INTERACTIVE_QUESTION_AREA
	LDY #0

DISPLAY_FILE_NAME_PROMPT
	LDA NEW_FILE_NAME_PROMPT_TEXT,Y
	STA SCREEN_TEXT_START + [ USER_PROMPT_LINE * TEXT_LINE_WIDTH ] , Y
	INY
	CPY #NEW_FILE_NAME_PROMPT_TEXT_LENGTH
	BNE DISPLAY_FILE_NAME_PROMPT

	STY FNAME_DISPLAY_INDEX
	LDX #0
	STX FNAME_LENGTH
	
GET_FILE_NAME_TEXT_CHAR

;	BGET 2,FNAME_CHAR,1

	LDX #KEYBOARD_INPUT_HANDLE
	LDA #CGBINR
	STA ICCOM,X
	LDA # <FNAME_CHAR
	STA ICBADR,X
	LDA # >FNAME_CHAR
	STA ICBADR+1,X
	LDA # <1
	STA ICBLEN,X
	LDA # >1
	STA ICBLEN+1,X
	JSR CIO

	LDA FNAME_CHAR
	CMP #EOL
	BNE MORE_CHARS

	LDA FNAME_LENGTH
	BEQ GET_FILE_NAME_TEXT_CHAR

	JMP BACK_TO_INPUT_HANDLER

MORE_CHARS
	CMP #BACKSPACE_CHAR
	BEQ PROCESS_BACKSPACE
	CMP #'Z + 1
	BPL GET_FILE_NAME_TEXT_CHAR
	CMP #'0
	BMI GET_FILE_NAME_TEXT_CHAR
	CMP #':
	BMI	OUTPUT_FNAME_CHAR
	CMP #'A
	BMI GET_FILE_NAME_TEXT_CHAR
	JMP OUTPUT_FNAME_CHAR
	
PROCESS_BACKSPACE
	LDY FNAME_DISPLAY_INDEX	
	LDA #0
	STA SCREEN_TEXT_START + [ USER_PROMPT_LINE * TEXT_LINE_WIDTH ] ,Y
	LDX FNAME_LENGTH
	BEQ GET_FILE_NAME_TEXT_CHAR
	DEC FNAME_LENGTH
	DEC FNAME_DISPLAY_INDEX
	DEY
	STA SCREEN_TEXT_START + [ USER_PROMPT_LINE * TEXT_LINE_WIDTH ] ,Y
	STA FNAME_TMP,X
	JMP GET_FILE_NAME_TEXT_CHAR	

OUTPUT_FNAME_CHAR
	SEC
	SBC #$20
	LDY FNAME_DISPLAY_INDEX	
	LDX FNAME_LENGTH
	CPX #8
	BEQ GET_FILE_NAME_TEXT_CHAR
	STA SCREEN_TEXT_START + [ USER_PROMPT_LINE * TEXT_LINE_WIDTH ] ,Y
	STA FNAME_TMP,X
	INC FNAME_DISPLAY_INDEX
	INC FNAME_LENGTH
	JMP GET_FILE_NAME_TEXT_CHAR	

BACK_TO_INPUT_HANDLER
	LDA #0
	LDY #0
CLEAR_USER_PROMPT_LINE
	STA SCREEN_TEXT_START + [ USER_PROMPT_LINE * TEXT_LINE_WIDTH ] ,Y
	INY
	CPY #TEXT_LINE_WIDTH
	BNE CLEAR_USER_PROMPT_LINE
	LDY #0
COPY_FILE_NAME_TO_DESTINATION_BUFFER	
	LDA FNAME_TMP,Y
	STA DESTINATION_FILE_NAME,Y
	STA STATUS_LINE_DESTINATION_FILE_NAME,Y
	CLC
	ADC #$20
	STA EXISTING_FILE_NAME_BUFFER,Y	
	INY
	CPY FNAME_LENGTH
	BNE COPY_FILE_NAME_TO_DESTINATION_BUFFER
	LDX #0
COPY_FILE_EXTENSION_TO_DESTINATION_BUFFER	
	LDA FNAME_EXTENSION,X
	STA DESTINATION_FILE_NAME,Y
	STA STATUS_LINE_DESTINATION_FILE_NAME,Y
	CLC
	ADC #$20
	STA EXISTING_FILE_NAME_BUFFER,Y	
	INY
	INX
	CPX #4
	BNE COPY_FILE_EXTENSION_TO_DESTINATION_BUFFER
	LDA #0
CLEAR_REST_OF_FILE_NAME
	STA DESTINATION_FILE_NAME,Y
	STA STATUS_LINE_DESTINATION_FILE_NAME,Y
	INY
	CPY #DESTINATION_FILE_NAME_LENGHT
	BNE CLEAR_REST_OF_FILE_NAME	
	RTS


UPDATE_STATUS_READ_SECTOR
	LDA DAUX1
	STA BIN_VAL
	LDA DAUX2
	STA BIN_VAL+1

	JSR BINBCD16
	
	LDA BCD_VAL
	CLC
	AND #$0F
	TAY
	LDA DECIMAL_TO_SCREEN,Y
	STA DISK_SECTOR_VAL+5
	
	LDA BCD_VAL
	AND #$F0
	CLC
	ROR 
	ROR 
	ROR 
	ROR 
	
	TAY
	LDA DECIMAL_TO_SCREEN,Y	
	STA DISK_SECTOR_VAL+4

	LDA BCD_VAL+1
	AND #$0F
	TAY
	LDA DECIMAL_TO_SCREEN,Y
	STA DISK_SECTOR_VAL+3
	
	LDA BCD_VAL+1
	AND #$F0
	CLC
	ROR 
	ROR 
	ROR 
	ROR 
	
	TAY
	LDA DECIMAL_TO_SCREEN,Y	

	STA DISK_SECTOR_VAL+2

	LDA BCD_VAL+2
	AND #$0F
	TAY
	LDA DECIMAL_TO_SCREEN,Y
	STA DISK_SECTOR_VAL+1
	
	LDA BCD_VAL+2
	AND #$F0
	CLC
	ROR 
	ROR 
	ROR 
	ROR 
	
	TAY
	LDA DECIMAL_TO_SCREEN,Y	

	STA DISK_SECTOR_VAL

	JSR DISPLAY_STATUS_LINE

	RTS

UPDATE_STATUS_SECTOR_SIZE
	
	LDA PERCOM_BYTES_PER_SECTOR_LO
	STA BIN_VAL
	LDA PERCOM_BYTES_PER_SECTOR_HI
	STA BIN_VAL+1

	JSR BINBCD16
	
	LDA BCD_VAL
	CLC
	AND #$0F
	TAY
	LDA DECIMAL_TO_SCREEN,Y
	STA DISK_SECTOR_SIZE_VAL+3
	
	
	LDA BCD_VAL
	AND #$F0
	CLC
	ROR 
	ROR 
	ROR 
	ROR 
	
	TAY
	LDA DECIMAL_TO_SCREEN,Y	
	STA DISK_SECTOR_SIZE_VAL+2

	LDA BCD_VAL+1
	AND #$0F
	TAY
	LDA DECIMAL_TO_SCREEN,Y
	STA DISK_SECTOR_SIZE_VAL+1
	
	LDA BCD_VAL+1
	AND #$F0
	CLC
	ROR 
	ROR 
	ROR 
	ROR 
	
	TAY
	LDA DECIMAL_TO_SCREEN,Y	

	STA DISK_SECTOR_SIZE_VAL

	JSR DISPLAY_STATUS_LINE


	RTS

UPDATE_STATUS_NUMBER_OF_HEADS
	
	LDY PERCOM_NUMBER_OF_SIDES
	INY
	STY BIN_VAL
	LDA #0
	STA BIN_VAL+1

	JSR BINBCD16
	
	LDA BCD_VAL
	CLC
	AND #$0F
	TAY
	LDA DECIMAL_TO_SCREEN,Y
	STA DISK_NUMBER_OF_HEADS_VAL+1
	
	
	LDA BCD_VAL
	AND #$F0
	CLC
	ROR 
	ROR 
	ROR 
	ROR 
	
	TAY
	LDA DECIMAL_TO_SCREEN,Y	
	STA DISK_NUMBER_OF_HEADS_VAL

	JSR DISPLAY_STATUS_LINE

	RTS


; 16-bit hex value to 24 bit decimal
; http://www.6502.org/source/integers/hex2dec-more.htm

BINBCD16
		SED		; Switch to decimal mode
		LDA #0		; Ensure the result is clear
		STA BCD_VAL+0
		STA BCD_VAL+1
		STA BCD_VAL+2
		LDX #$10		; The number of source bits

CNVBIT		
		ASL BIN_VAL+0	; Shift out one bit
		ROL BIN_VAL+1
		LDA BCD_VAL+0	; And add into result
		ADC BCD_VAL+0
		STA BCD_VAL+0
		LDA BCD_VAL+1	; propagating any carry
		ADC BCD_VAL+1
		STA BCD_VAL+1
		LDA BCD_VAL+2	; ... thru whole result
		ADC BCD_VAL+2
		STA BCD_VAL+2
		DEX		; And repeat for next bit
		BNE CNVBIT
		CLD		; Back to binary
;
		RTS		; All Done.

REFRESH_MAIN_MENU

	JSR CLEAR_TEXT_SCREEN 
	JSR DISPLAY_MAIN_MENU_LAYOUT
	RTS


READ_PERCOM_BLOCK

	LDA #$4E				
	STA DCOMND
	LDA #$40
	STA DSTATS

	LDA #$31								
	STA DDEVIC

	LDA CALCULATED_SOURCE_DRIVE_NUMBER			; Supplied by user
	STA DUNIT
	LDA #$20					
	STA DTIMLO
	LDA #<PERCOM_BLOCK_BUFFER_SIZE						; 12 byte Percom block returned
	STA DBYTLO
	LDA #>PERCOM_BLOCK_BUFFER_SIZE
	STA DBYTHI
	LDA #<PERCOM_BLOCK_BUFFER
	STA DBUFLO
	LDA #>PERCOM_BLOCK_BUFFER
	STA DBUFHI
    JSR	SIOV
	
	BMI CANT_READ_PERCOM_BLOCK		
									; need to check on what gets returned to see if drive supports
									; percom, and if it does. adjust percom block for each density
	CLC
	RTS
	
CANT_READ_PERCOM_BLOCK
	SEC
	RTS

DISPLAY_TEXT_UP_TO_EOZ

	LDY #0
LOOP_COPY_TEXT_LINE
	LDA (ZSOURCE),Y
	CMP #EOL
	BEQ NEXT_TEXT_LINE
	CMP #EOZ
	BEQ DONE_DISPLAYING_TEXT
	STA (ZDEST),Y
	INY
	BNE LOOP_COPY_TEXT_LINE	
	
DONE_DISPLAYING_TEXT	
	RTS

NEXT_TEXT_LINE
	; Add number of characters read to  page zero counter
	INY
	TYA
	CLC
	ADC ZSOURCE_LO
	STA ZSOURCE_LO
	LDA #0
	ADC ZSOURCE_HI
	STA ZSOURCE_HI

				; Add TEXT_LINE_WIDTH byte display line to page zero counter
	CLC
	LDA ZDEST_LO
	ADC #TEXT_LINE_WIDTH
	STA ZDEST_LO
	LDA ZDEST_HI
	ADC #0
	STA ZDEST_HI
	
	LDY #0
	BEQ LOOP_COPY_TEXT_LINE	

WAIT_TO_CONTINUE
;	BGET 2,WAIT_TO_CONTINUE_CHAR,1

	LDX #KEYBOARD_INPUT_HANDLE
	LDA #CGBINR
	STA ICCOM,X
	LDA # <WAIT_TO_CONTINUE_CHAR
	STA ICBADR,X
	LDA # >WAIT_TO_CONTINUE_CHAR
	STA ICBADR+1,X
	LDA # <1
	STA ICBLEN,X
	LDA # >1
	STA ICBLEN+1,X
	JSR CIO

	LDA WAIT_TO_CONTINUE_CHAR
	CMP #'C
	BNE WAIT_TO_CONTINUE
	RTS	

ASK_YES_OR_NO
;	BGET 2,YES_OR_NO_CHAR,1

	LDX #KEYBOARD_INPUT_HANDLE
	LDA #CGBINR
	STA ICCOM,X
	LDA # <YES_OR_NO_CHAR
	STA ICBADR,X
	LDA # >YES_OR_NO_CHAR
	STA ICBADR+1,X
	LDA # <1
	STA ICBLEN,X
	LDA # >1
	STA ICBLEN+1,X
	JSR CIO

	LDA YES_OR_NO_CHAR
	CMP #'N
	BEQ USER_ANSWERED_NO
	CMP #'Y
	BNE ASK_YES_OR_NO
USER_ANSWERED_YES
	CLC
	RTS
USER_ANSWERED_NO
	SEC
	RTS

CHECK_DRIVE_STATUS
	LDA #$53				
	STA DCOMND
	LDA #$40
	STA DSTATS

	LDA #$31
	STA DDEVIC
	
	LDY #CURRENT_FIELD_VALUE
	LDA SOURCE_FIELD_DATA,Y				; Supplied by user

	TAY
	INY									; indexed value, starts at 0

	STY CALCULATED_SOURCE_DRIVE_NUMBER	
										; save it for later so that this 
										; doesn't have to be calculated again
										; not sure this is faster though

	STY DUNIT
	LDA #20							
	STA DTIMLO
	LDA #4							; 4 byte status returned
	STA DBYTLO
	LDA #0
	STA DBYTHI
	LDA #<DRIVE_STATUS_BUFFER			; use sector buffer for 4 bytes returned by drive
	STA DBUFLO
	LDA #>DRIVE_STATUS_BUFFER
	STA DBUFHI
    JSR	SIOV
	BMI DRIVE_NOT_GOOD	
	CLC
	RTS

DRIVE_NOT_GOOD  
	SEC
	RTS


CLEAR_TEXT_SCREEN
	LDA #0
	LDY #0
LOOP_CLEAR_TEXT_LINE
	STA SCREEN_TEXT_START + [0 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [1 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [2 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [3 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [4 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [5 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [6 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [7 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [8 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [9 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [10 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [11 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [12 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [13 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [14 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [15 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [16 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [17 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [18 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [19 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [20 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [21 * TEXT_LINE_WIDTH],Y
	STA SCREEN_TEXT_START + [22 * TEXT_LINE_WIDTH],Y
;	STA SCREEN_TEXT_START + [23 * TEXT_LINE_WIDTH],Y
;	STA SCREEN_TEXT_START + [24 * TEXT_LINE_WIDTH],Y
;	STA SCREEN_TEXT_START + [0 * TEXT_LINE_WIDTH],Y

	INY
	CPY #TEXT_LINE_WIDTH
	BNE LOOP_CLEAR_TEXT_LINE
	RTS			



PROCESS_MAIN_MENU_INPUT

; table driven input processor
	LDY #0
TEST_IF_COMMAND
	CMP MAIN_MENU_COMMAND_CODES,Y
	BEQ FOUND_A_COMMAND
	INY
	CPY #NUMBER_OF_MAIN_MENU_COMMAND_CODES	
	BNE TEST_IF_COMMAND
	RTS
	
FOUND_A_COMMAND	
	LDA MAIN_MENU_FIELD_PROCESS_JUMP_VECTOR_LO,Y
	STA ZCOMMAND_VECTOR_LO
	LDA MAIN_MENU_FIELD_PROCESS_JUMP_VECTOR_HI,Y
	STA ZCOMMAND_VECTOR_HI
	JMP (ZCOMMAND_VECTOR)


UPDATE_FIELD
	JSR UPDATE_OR_ROLLOVER_FIELD
	JSR UPDATE_MENU_VALUE
	RTS


DISPLAY_MAIN_MENU_LAYOUT

	JSR CLEAR_TEXT_SCREEN

	LDA #0
	STA CURRENT_ELEMENT

NEXT_ELEMENT
	LDY CURRENT_ELEMENT
	LDA SCREEN_ELEMENTS,Y	
	STA ZFIELD_STRUCTURE_LO
	INY
	LDA SCREEN_ELEMENTS,Y	
	STA ZFIELD_STRUCTURE_HI
	INY
	STY CURRENT_ELEMENT
	CPY #NUMBER_OF_SCREEN_ELEMENTS
	BNE Y_OK
	RTS
Y_OK	
	JSR UPDATE_MENU_VALUE
	JMP NEXT_ELEMENT
	

DISPLAY_STATUS_LINE

	LDA #<STATUS_LINE_DATA
	STA ZFIELD_STRUCTURE_LO
	LDA #>STATUS_LINE_DATA	
	STA ZFIELD_STRUCTURE_HI
	
	JSR UPDATE_MENU_VALUE

	RTS
	

UPDATE_MENU_VALUE
;
; this subroutine processes a field, with a label and value 
;
	
	; setup destination pointer for start of field -> starts at current 
	; field structure + SCREEN_DESTINATION_ADDRESS

	LDY #SCREEN_DESTINATION_ADDRESS_LABEL
	LDA (ZFIELD_STRUCTURE),Y
	STA ZDEST_LO
	INY
	LDA (ZFIELD_STRUCTURE),Y
	STA ZDEST_HI

	; setup source pointer to label text -> starts at current 
	; field structure + START_OF_TEXT_VALUES

	CLC
	LDA ZFIELD_STRUCTURE_LO
	ADC #START_OF_TEXT_VALUES
	STA ZSOURCE_LO
	LDA ZFIELD_STRUCTURE_HI
	ADC #0
	STA ZSOURCE_HI

	; copy label text to screen	 

	JSR	WRITE_TEXT_TO_SCREEN
	
DONE_LABEL_COPY

	TYA				; save index to end of label text (EOL) in X
	TAX				; start of values_text-1, saved in X
	INX				; now X holds the offset to the start 
					; of values_text
	LDY #NUMBER_OF_VALUES	
	LDA (ZFIELD_STRUCTURE),Y
	BNE DISPLAY_VALUE		; zero value means just label text only

	RTS						; only needed to display the label

DISPLAY_VALUE

	; update source pointer to start of values_text, 
	; this frees up registers too

	TXA
	CLC
	ADC ZSOURCE_LO
	STA ZSOURCE_LO
	LDA #0
	ADC ZSOURCE_HI
	STA ZSOURCE_HI


	LDY #CURRENT_FIELD_VALUE
	LDA (ZFIELD_STRUCTURE),Y

	TAX					; counter for field value text
CHECK_TO_SEE_IF_THIS_VALUE_IS_THE_CORRECT_ONE
	CPX #0
	BNE FIND_NEXT_TEXT_VALUE
	
	LDY #SCREEN_DESTINATION_ADDRESS_VALUE
	LDA (ZFIELD_STRUCTURE),Y
	STA ZDEST_LO
	INY
	LDA (ZFIELD_STRUCTURE),Y
	STA ZDEST_HI
	
	JMP WRITE_TEXT_TO_SCREEN			; return is handled in WRITE_TEXT_TO_SCREEN
FIND_NEXT_TEXT_VALUE
	LDY #0
	
LOOP_FIND_NEXT_TEXT_VALUE	
	LDA (ZSOURCE),Y
	INY
	CMP #EOL
	BEQ UPDATE_SOURCE_POINTERS
	
	JMP LOOP_FIND_NEXT_TEXT_VALUE

UPDATE_SOURCE_POINTERS
	CLC
	TYA
	ADC ZSOURCE_LO
	STA ZSOURCE_LO
	LDA #0
	ADC ZSOURCE_HI
	STA ZSOURCE_HI
	DEX
	JMP CHECK_TO_SEE_IF_THIS_VALUE_IS_THE_CORRECT_ONE


CLOSE_ATR_FILE
    LDX #ATR_FILE_HANDLE
	LDA #CCLOSE
    STA ICCOM,X
	JSR CIO
	RTS


WRITE_TEXT_TO_SCREEN
	LDY #0
LOOP_TEXT_COPY
	LDA (ZSOURCE),Y
	CMP #EOL
	BEQ DONE_TEXT_COPY
	STA (ZDEST),Y
	INY
	JMP LOOP_TEXT_COPY			; this will lock-up if 
										; there is no EOL in first 256 bytes of source data
DONE_TEXT_COPY
	; Y holds length of copied text
	RTS


UPDATE_OR_ROLLOVER_FIELD
	; see if field has rolled over, handle that if it has
		
	LDY #CURRENT_FIELD_VALUE
	LDA (ZFIELD_STRUCTURE),Y
	
	TAY  ; add 1 to current field value
	INY
	TYA
	 	
	LDY #NUMBER_OF_VALUES
	CMP (ZFIELD_STRUCTURE),Y
	BNE SAVE_NEW_FIELD_VALUE
	LDA #0						; reset field value	
	; save updated value 
SAVE_NEW_FIELD_VALUE
	LDY #CURRENT_FIELD_VALUE
	STA (ZFIELD_STRUCTURE),Y

; current field value has been incremented, or rolled over (reset to zero)
;
	RTS


UPDATE_MENU_FIELD
	LDY #0
LOOP_COPY_MENU_FIELD_DATA
	LDA (ZSOURCE),Y
	STA (ZDEST),Y
	INY
	CMP #EOL
	BNE LOOP_COPY_MENU_FIELD_DATA
	RTS
	

SECTOR_BUFFER						; shouldn't be any drives with more



	* = $2E0
	.WORD PROGRAM_INIT

		